# 1. 자바



## 변수(Variable) - 2장

#### 변수의 특성

- 이름이 있음 - 변수명 (메모리 주소에 붙여진 이름)
- 기억 장소 내에서의 주소가 있음
- 변수에 저장되는 값이 있음
- 저장되는 값의 유형(데이터 타입)이 있고 크기가 다름
- 프로그램 실행 중에 저장된 값이 변경될 수 있음
  -  b = 300; // 덮어 쓴다 (이전에 있던 값 사라짐)
  -  b = 500;
  - 주의! 변수는 동일한 이름으로 한 번만 선언 (중복 선언하면 오류)


#### 변수 이름을 위한 명명 규칙

| **작성 규칙**                                                | **예**                                                       |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 첫 번째 글자는 문자이거나 ‘$’ , ‘_’ 여야 하고 숫자로 시작할 수 없다. (필수) | 가능 : price, $price,  _companyName  불가 : 1v, @speed,  $#value |
| 영어 대/소문자가 구분된다. (필수)                            | firstname 과 firstName 은 다른 변수                          |
| 첫 문자는 영어 소문자로 시작하되, 다른 단어가 붙을 경우 첫 자를 대문자로 한다. (관례) | maxSpeed, firstName, carBodyColor                            |
| 문자 수(길이)의 제한은 없다.                                 |                                                              |
| 자바 예약어는 사용할 수 없다. (필수)                         | 하단 참조                                                    |



#### 변수 선언

- 변수를 사용하기 위해서는 반드시 변수를 선언해야 함
- 선언하지 않으면 오류 발생
  - 오류 메세지 : 변수명 cannot be resolved to a variable
- 변수를 선언하는 이유는 실행 중에 필요한 공간을 할당 받기 위함
- 선언 형식 : 데이터 타입 변수명;
  - int a; // 선언만 하고 초기화하지 않은 경우
  - 정수 값을 저장하기 위해 a라는 이름으로 정수 타입 변수 선언
    - 정수를 저장할 크기 4 byte 저장 공간 확보
  - int b = 100; // 선언과 동시에 초기화
- 선언된 변수에 값 저장 : 변수명 = 값 (저장소 = 값)
  - 대입 연산자 =의 오른쪽의 값을 왼쪽의 저장소(변수)에 저장



#### 주의! 초기화 되지 않은 변수 사용 시 오류 발생

- int value; // 선언만 하고 초기화 안 했음
- int result = value + 10; 
  - 변수 value에 10을 더한 결과를 변수 result에 저장
  - 오류 발생 : value가 초기화 되지 않았다고 오류 발생
    The local variable value may not have been initialized
- int value = 30; // 초기화 한 후 
- int result = value + 10; // 변수 사용



## 연산자 (코드 실행 결과) - 3장, 4장

#### 비교 연산자 : < , <= , > , >= , == , !=

- 대소 : <, <=, >, >=
- 동등 : == (같다) , != (같지 않다)
- 비교 결과는 Boolean 타입인 true, false로 확인
- 주의! = 은 대입 연산자 , == 은 비교 연산자

**![텍스트, 화면, 스크린샷이(가) 표시된 사진  자동 생성된 설명](test.assets/clip_image001.png)**

- 동등 비교 연산자는 모든 타입에 사용
- 크기 비교 연산자는 boolean 타입을 제외한 모든 기본 타입에 사용
- 문자열 비교에는 == 사용하지 않고 equals() 메소드 사용 – String 객체는 나중에 상세히 설명
- 흐름 제어문인 조건문과 반복문에서 주로 이용 : 실행 흐름을 제어할 때 사용



#### 반복문 (while)

- 조건에 따라 반복을 계속할지 결정할 때 사용
- 조건식이 true일 경우 계속해서 반복 (for문은 정해진 횟수만큼 반복)
- 주의!
  - 초기값이 없으면 조건을 알 수 없고 증감식이 없으면 반복문을 빠져 나올 수 없어서 무한 반복
    - i가 증가하지 않으면 계속 10 이하로
    - 조건이 계속 true 상태 > 계속 반복



#### SUM 구하는 방법 : EX 짝수의 합 구하는 법

```java
int i = 1;
		int sum = 0;
		
		while(i <= 100) {
			if(i % 2 == 0) {
				sum += i;
			}
			i++;
		}
		
		System.out.println("1 ~ " + (i - 1) + " 짝수의 합 : " + sum );
```



#### 증감 연산자 위치에 따른 결과 구분

```java
int x = 10;
int y = 10;
int z;

x++;
++x;
System.out.println(x); // 12

y--;
--y;
System.out.println(y); // 8

z = x++;
System.out.println(z); // 12
System.out.println(x); // 13

z = ++x;
System.out.println(z); // 14
System.out.println(x); // 14

z = ++x + y++;
System.out.println(z); // 23
System.out.println(x); // 15
System.out.println(y); // 9

```





## 제어문 (코드) - 4장

#### 조건문 (if)

- if( 조건식 ) { 조건식의 결과가 true일 때 수행되는 문장 }



#### 반복문 (for)

- 반복 횟수를 알고 있을 때 주로 사용
- 반복 횟수 지정
- for( 초기식;  조건식;  증감식 ){ 반복 수행 문장 }



#### break

- 반복문 하나를 완전히 빠져 나갈 때 사용
- for문, while문, do ~ while문 종료 : 반복 취소
- switch문 종료 시 사용
- 주로 if문과 같이 사용 : if문 조건식에 따라 반복문 종료
- 주의! 반복문이 중첩되어 있는 경우, 자신이 속한 가장 가까운 하나의 반복문만 벗어남
- 바깥쪽 반복문까지 종료 시키려면 반복문에 이름을 붙이고 “break 이름;” 사용



#### Continue

- 수행 중인 문장은 중단하고, 다음 반복 계속 수행
- 반복문은 종료하지 않고 계속 반복 수행



## 생성자 - 6장

- 객체가 생성되는 순간에 자동으로 호출되는 메소드
- 객체가 생성될 때 초기화를 위해 사용
- 생성자가 없다면, 객체를 초기화하는 메소드를 만들고 초기화를 위해 이 메소드를 반드시 호출해줘야 함



#### 특징

- 클래스 이름과 동일
- 반환값 / 반환형이 없음
- new 연산자를 통해 객체를 생성할 때만 단 한 번 자동으로 호출
- 아무 때나 호출해서 사용할 수 없음
- 오버로딩 가능
  - 오버로딩 : 여러 개의 생성자(매개변수 다르게)
  - 매개변수 개수와 데이터 타입 다르게
  - 생성자 여러개 사용 가능



#### 생성자 오버로딩

하나의 클래스에 생성자를 여러 개 기술하면 객체 생성 시 매개변수의 개수, 데이터 타입, 순서가 일치하는 생성자를 알아서 호출



#### 생성자의 용도

- 멤버 필드 초기화
- 객체가 처음 생성되는 순간에 처리할 작업 수행
- public Test(float rate, String name) { 
  this.rate = rate;
  this.name = name;}



## static / 인스턴스 멤버 - 6장

#### 인스턴스 멤버

- non-static 멤버
- 객체를 통해서 접근
- 지금까지 우리가 만들었던 객체(인스턴스) 멤버
- 객체가 생성될 때 각 객체 내부에 하나씩 생성
- 객체마다 자신의 고유 멤버 공간을 가짐
- 다른 객체들과 공유하지 않음
- 객체가 사라지면 함께 사라짐



#### Static 멤버 = 정적 멤버

- 클래스에 고정된 필드와 메소드
- 클래스에 소속된 멤버 (클래스 당 하나만 생성)
  - 객체를 생성하지 않고 클래스로 바로 접근해서 사용
- 클래스 내의 모든 객체들이 공유
- 프로그램이 시작될 때 이미 생성
  - 객체보다 먼저 생성됨
- 프로그램이 종료될 때 사라짐



#### static의 활용

1. 객체들 간의 공유 멤버로 활용
   - static 선언된 필드나 메소드는 클래스 내의 각 객체들이 공통으로 사용 가능
   - 모든 객체가 공유

2. 전역 변수와 전역 함수 만들 때 사용
   - 자바에서는 어떤 변수나 함수(메소드)도 클래스 밖에 존재할 수 없음
   - 모든 변수와 메소드는 클래스의 멤버로 존재 : 캡슐화의 원칙
   - 그러나 응용프로그램 작성 시 클래스가 여러 개 있는 경우 모든 클래스에서 공유할 수 있는 전역 변수와 전역 함수 필요
     - 이런 문제를 해결하기 위해 static 사용



#### static 초기화 블록

- static { }
- 클래스가 메소드 영역(static 영역)으로 로딩될 때 자동으로 실행되는 블록
- 클래스 내부에 여러 개가 선언되면 선언된 순서대로 실행
- static 필드의 복잡한 초기화 작업과 static 메소드 호출 가능



#### static 멤버 vs 인스턴스 멤버(non-static) 멤버 비교

**![img](test.assets/clip_image001-4760389.png)**



## 상속 (코드) - 7장

#### 상속 키워드

#### 자바 상속의 특징

- 다중 상속을 지원하지 않음
- extends 다음에는 오직 한 개의 클래스만 사용
- 상속 횟수는 제한 없음
- 계층 구조의 최상위에 있는 클래스는 java.lang.Objcet 클래스
- 따라서 모든 클래스는 Object 클래스로부터 상속 받는 것 (Object 상속을 표현하지 않더라도 자동으로 상속 받게 됨)

#### 상속 코드 작성법





## super() / this() - 7장 / 자료 6장

> 의미, 위치, 차이

#### super

- super 레퍼런스 : 슈퍼 클래스(부모 클래스)를 가리키는 레퍼런스
- super() 메소드 : 슈퍼 클래스의 생성자를 호출하는 메소드 / 생성자 안에서 맨 첫 줄에 와야 함



#### this

- this 레퍼런스 : 클래스 내에서 객체 자신을 가리키는 레퍼런스
- this() 메소드 : 한 생성자에서 다른 생성자 호출하는 메소드 / 생성자 안에서 맨 첫 줄에 와야 함



## interface - 8장

#### 의미

- 객체의 사용 방법을 정의한 타입
- 클래스들이 구현해야 하는 동작을 지정하는데 사용되는 추상형
- 미리 정해진 규칙에 맞게 구현하도록 표준을 제시하기 위해 사용
- 추상 클래스와 유사, 기본 설계도의 의미 (규격/표준을 정함)



#### 역할

- 개발 코드와 객체가 서로 통신하는 접점 역할
- 개발 코드가 인터페이스의 메소드를 호출하면 인터페이스는 객체의 메소드 호출
- 개발 코드는 객체의 내부 구조를 알 필요 없고 인터페이스의 메소드만 알면 됨



#### 특징

- 인터페이스는 객체를 생성할 수 없다
  - 구현되지 않은 추상 메소드를 포함하고 있기 때문
- 객체를 생성할 수 없기 때문에 생성자를 가질 수 없음
- 인터페이스 간에 상속
- 인터페이스를 상속받아 클래스를 구현하면 인터페이스의 모든 추상 메소드를 구현해야 함



## 제네릭 - 13장

#### 의미

- 클래스(인터페이스)나 메소드를 타입파라미터를 이용하는 기법
- 클래스 설계 시에 타입 <T>이 아직 결정 되지 않음
- 총칭해서 제네릭 타입
- public class 클래스명<T> {. .. }
- public interface 인터페이스명<T> { }



#### 코드의 이점

- 컴파일 시 강한 타입 체크 가능
  - 실행 시 타입 에러가 나는 것 방지
  - 컴파일 시 미리 타입을 강하게 체크해서 에러를 사전에 방지
- 강제 타입 변환 제거 가능 (프로그램 성능 향상)



#### 제네릭 정리

클래스나 인터페이스를 설계할 때 구체적인 타입을 명시하지 않고 타입 파라미터로 대체했다가 실제 클래스 사용될 때 구체적인 타입을 지정하여 타입 변환을 최소화시킴으로써 프로그램 성능을 향상시킬 수 있고 컴파일 시 미리 타입을 강하게 체크해서 에러를 사전에 방지



## 예외처리(코드) - 10장

> 예외처리 구문

예외 발생 시 프로그램 종료되지 않게 하고 정상 실행을 유지할 수 있도록 처리하는 코드

 \- 일반 예외 : 반드시 작성해야 컴파일 가능

 \- 실행 예외 : 컴파일러가 체크해주지 않으며 개발자의 경험에 의해 작성

  : 일부는 이클립스가 주의를 주기 떄문에 미리 알 수 있음

**try ~ catch ~finally** 블록을 이용해서 예외 처리 코드 작성

try ~ catch 구문 자동 삽입 : Surround With (Source에도 있고 오른쪽 클릭하고도 있음)

 \- 예외 처리할 문장 모두 드래그해서 선택하고 진행



![img](test.assets/clip_image001-4761109.png)





# 데이터베이스



DDL (코드)
- ALTER

DML (코드)
- SELECT

DCL (코드)
- 사용자 계정 생성

JDBC 연결과정 순서

JDBC (코드)
- 자바 코드에서 SELECT 문 쿼리 작성 해서 결과 받아오는 과정

